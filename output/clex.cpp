#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <functional>
#include <fstream>

namespace HLex
{
    using std::map;
    using std::vector;
    using char_type = char;

    struct Token
    {
        std::string tag;
        std::string val;
        std::string to_string() const
        {
            return "<" + tag + "," + val + ">";
        }
    };
    void print_line(const std::string &s, int &pos)
    {
        int cnt = 100;
        while (pos < s.size() && cnt)
        {
            std::cout << s[pos++];
            cnt--;
        }
        std::cout.flush();
    }
    class Lexer
    {
    public:
        Lexer(const std::string &con);
        std::vector<Token> lex()
        {
            std::vector<Token> ret;
            int cur_state = entry;
            // to roll back state tag val
            std::vector<std::pair<int, Token>> pos_stac;
            // str pos
            int pos = 0;
            std::string cur_token;
            std::string cur_tag;

            while (pos < content.size())
            {
                if (tab[cur_state].count(content[pos]))
                {
                    cur_state = tab[cur_state][content[pos]];
                    cur_token += content[pos];

                    if (fin_stat_tab.count(cur_state))
                    {
                        if (fin_stat_tab[cur_state] != "")
                            cur_tag = fin_stat_tab[cur_state];

                        pos_stac.clear();
                        pos_stac.push_back({pos + 1, {cur_tag, cur_token}});
                    }
                    pos++;
                }
                else
                {
                    if (pos_stac.empty())
                    {
                        print_line(content,pos);
                        throw std::runtime_error(" LexerGenerator::lex: Lexer Error");
                    }
                    auto [p, tok] = pos_stac.back();
                    // if a symbol is a keyword pr ignore
                    auto val = tok.val;
                    if (keywords.count(val))
                        tok = Token{keywords[val], val};
                    if (user_defs.count(tok.tag))
                    {
                        p -= tok.val.size();
                        tok.val = user_defs[tok.tag](content, p);
                    }
                    if (!ignore.count(tok.tag))
                        ret.push_back(tok);

                    // roll back
                    pos = p;
                    cur_state = entry;
                    cur_token = cur_tag = "";
                    pos_stac.clear();
                }
            }
            if (pos_stac.size())
                ret.push_back(pos_stac.back().second);
            return ret;
        }

    private:
        std::string content;
        int pos = 0;

        std::map<std::string, std::string> keywords;
        std::map<std::string, std::function<std::string(const std::string &, int &)>> user_defs;
        std::set<std::string> ignore;

        int entry;
        map<int, std::string> fin_stat_tab;
        vector<map<char_type, int>> tab;
    };
    
    std::string read_file(const std::string &filename)
    {
        std::ifstream ifs(filename, std::ios::in | std::ios::binary);
        if (!ifs)
            throw std::runtime_error("open file " + filename + " failed\n");
        char *file_content;
        ifs.seekg(0, std::ios::end);
        size_t file_length = ifs.tellg();
        ifs.seekg(0, std::ios::beg);

        file_content = new char[file_length];

        ifs.read(file_content, file_length);
        ifs.close();

        std::string str(file_content, file_content + file_length);
        delete[] file_content;
        return str;
    }
}
// Following code is generated by program 
namespace HLex{
Lexer::Lexer(const std::string &con):content(con),entry(52){
fin_stat_tab = {{1,"ADD"},{2,"AND"},{3,"ANNOTATION"},{4,"ASSIGN"},{5,"BAND"},{6,"BEGIN"},{7,"BNOT"},{8,"BOR"},{9,"BXOR"},{10,"CHAR_LIT"},{11,"COLON"},{12,"COMMA"},{13,"DIV"},{14,"DOT"},{15,"END"},{16,"EQ"},{17,"GE"},{18,"GT"},{19,"LE"},{20,"LITERAL"},{21,"LONG"},{22,"LPAR"},{23,"LSH"},{24,"LSP"},{25,"LT"},{26,"MEM_VIS"},{27,"MOD"},{28,"MUL"},{29,"NE"},{30,"NEWLINE"},{31,"NOT"},{32,"NUMBER"},{33,"OR"},{34,"QUE"},{35,"REAL"},{36,"RPAR"},{37,"RSH"},{38,"RSP"},{39,"SADD"},{40,"SAND"},{41,"SDIV"},{42,"SLSH"},{43,"SMOD"},{44,"SMUL"},{45,"SOR"},{46,"SPACE"},{47,"SRSH"},{48,"SSUB"},{49,"SUB"},{50,"SXOR"},{51,"SYMBOL"}};
tab = {{{'l',21}},{{'0',32},{'1',32},{'2',32},{'3',32},{'4',32},{'5',32},{'6',32},{'7',32},{'8',32},{'9',32},{'=',39}},{},{},{{'=',16}},{{'&',2},{'=',40}},{},{},{{'=',45},{'|',33}},{{'=',50}},{},{},{},{{'/',3},{'=',41}},{},{},{},{},{{'=',17},{'>',37}},{},{},{},{},{{'=',42}},{},{{'<',23},{'=',19}},{},{{'=',43}},{{'=',44}},{},{},{{'=',29}},{{'.',54},{'0',32},{'1',32},{'2',32},{'3',32},{'4',32},{'5',32},{'6',32},{'7',32},{'8',32},{'9',32},{'l',0}},{},{},{{'0',35},{'1',35},{'2',35},{'3',35},{'4',35},{'5',35},{'6',35},{'7',35},{'8',35},{'9',35}},{},{{'=',47}},{},{},{},{},{},{},{},{},{},{},{},{{'0',32},{'1',32},{'2',32},{'3',32},{'4',32},{'5',32},{'6',32},{'7',32},{'8',32},{'9',32},{'=',48},{'>',26}},{},{{'0',51},{'1',51},{'2',51},{'3',51},{'4',51},{'5',51},{'6',51},{'7',51},{'8',51},{'9',51},{'A',51},{'B',51},{'C',51},{'D',51},{'E',51},{'F',51},{'G',51},{'H',51},{'I',51},{'J',51},{'K',51},{'L',51},{'M',51},{'N',51},{'O',51},{'P',51},{'Q',51},{'R',51},{'S',51},{'T',51},{'U',51},{'V',51},{'W',51},{'X',51},{'Y',51},{'Z',51},{'_',51},{'a',51},{'b',51},{'c',51},{'d',51},{'e',51},{'f',51},{'g',51},{'h',51},{'i',51},{'j',51},{'k',51},{'l',51},{'m',51},{'n',51},{'o',51},{'p',51},{'q',51},{'r',51},{'s',51},{'t',51},{'u',51},{'v',51},{'w',51},{'x',51},{'y',51},{'z',51}},{{'\t',46},{'\n',30},{'\r',53},{' ',46},{'!',31},{'"',20},{'#',3},{'%',27},{'&',5},{'\'',10},{'(',22},{')',36},{'*',28},{'+',1},{',',12},{'-',49},{'.',14},{'/',13},{'0',32},{'1',32},{'2',32},{'3',32},{'4',32},{'5',32},{'6',32},{'7',32},{'8',32},{'9',32},{':',11},{';',12},{'<',25},{'=',4},{'>',18},{'?',34},{'A',51},{'B',51},{'C',51},{'D',51},{'E',51},{'F',51},{'G',51},{'H',51},{'I',51},{'J',51},{'K',51},{'L',51},{'M',51},{'N',51},{'O',51},{'P',51},{'Q',51},{'R',51},{'S',51},{'T',51},{'U',51},{'V',51},{'W',51},{'X',51},{'Y',51},{'Z',51},{'[',24},{']',38},{'^',9},{'_',51},{'a',51},{'b',51},{'c',51},{'d',51},{'e',51},{'f',51},{'g',51},{'h',51},{'i',51},{'j',51},{'k',51},{'l',51},{'m',51},{'n',51},{'o',51},{'p',51},{'q',51},{'r',51},{'s',51},{'t',51},{'u',51},{'v',51},{'w',51},{'x',51},{'y',51},{'z',51},{'{',6},{'|',8},{'}',15},{'~',7}},{{'\n',30}},{{'0',35},{'1',35},{'2',35},{'3',35},{'4',35},{'5',35},{'6',35},{'7',35},{'8',35},{'9',35}}};
ignore = {"ANNOTATION","SPACE"};
keywords = {{"","STRUCT"},{"break","BREAK"},{"case","CASE"},{"char","CHAR"},{"const","CONST"},{"continue","CONTINUE"},{"default","DEFAULT"},{"do","DO"},{"double","DOUBLE"},{"else","ELSE"},{"float","FLOAT"},{"for","FOR"},{"goto","GOTO"},{"if","IF"},{"int","INT"},{"long","LONG"},{"register","REGISTER"},{"return","RETURN"},{"short","SHORT"},{"signed","SIGNED"},{"static","STATIC"},{"switch","SWITCH"},{"typedef","TYPEDEF"},{"union","UNION"},{"unsigned","UNSIGNED"},{"void","VOID"},{"volatile","VOLATILE"},{"while","WHILE"}};
user_defs = {{"ANNOTATION",[](const std::string &s,int &pos){
    while(pos<s.size() && s[pos]!='\n')
        pos++;
    return "";
}},{"CHAR_LIT",[](const std::string &s,int &pos){
    pos++;
    std::map<char, std::string> escape = {
        {'n', "\n"}, {'t', "\t"}, {'r', "\r"}, {'\\', "\\"}, {'\'', "\\'"}, {'\"', "\""}};
    if (s[pos] == '\\')
    {
        pos++;
        if (pos == s.size() || !escape.count(s[pos]))
            throw std::runtime_error("invalid char");
        else
            return escape[s[pos++]];
    }
    // simple version
    std::string ret = std::string(1, s[pos]);
    pos++;
    return ret;
}},{"LITERAL",[](const std::string &s,int &pos){
    pos++;
    std::map<char, std::string> escape = {
         {'n', "\n"}, {'t', "\t"}, {'r', "\r"}, {'\\', "\\"}, {'\'', "\\'"}, {'\"', "\""}};
    std::string ret = "";
    while (pos < s.size() && s[pos] != '\"')
    {
        if (s[pos] == '\\')
        {
            if (pos == s.size())
                throw std::runtime_error("invalid string");
            pos++;
            if (!escape.count(s[pos]))
                throw std::runtime_error("invalid escape string!");
            ret += escape[s[pos]];
        }
        else
            ret += s[pos];
        pos++;
    }
    pos++;
    return ret;
}}};
}}
int main()
{
    try
    {
        HLex::Lexer L(HLex::read_file("clex.cpp"));
        auto vec = L.lex();
        for (auto item : vec)
        {
            std::cout << item.to_string();
        }
    }
    catch (std::exception &e)
    {
        std::cout << e.what();
    }
}