#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <functional>
#include <fstream>

namespace HLex
{
    using std::map;
    using std::vector;
    using char_type = char;

    struct Token
    {
        std::string tag;
        std::string val;
        std::string to_string() const
        {
            return "<" + tag + "," + val + ">";
        }
    };

    class Lexer
    {
    public:
        Lexer(const std::string &con);
        std::vector<Token> lex()
        {
            std::vector<Token> ret;
            int cur_state = entry;
            // to roll back state tag val
            std::vector<std::pair<int, Token>> pos_stac;
            // str pos
            int pos = 0;
            std::string cur_token;
            std::string cur_tag;

            while (pos < content.size())
            {
                if (tab[cur_state].count(content[pos]))
                {
                    cur_state = tab[cur_state][content[pos]];
                    cur_token += content[pos];

                    if (fin_stat_tab.count(cur_state))
                    {
                        if (fin_stat_tab[cur_state] != "")
                            cur_tag = fin_stat_tab[cur_state];

                        pos_stac.clear();
                        pos_stac.push_back({pos + 1, {cur_tag, cur_token}});
                    }
                    pos++;
                }
                else
                {
                    if (pos_stac.empty())
                        throw std::runtime_error("LexerGenerator::lex: Lexer Error");
                    auto [p, tok] = pos_stac.back();
                    // if a symbol is a keyword pr ignore
                    auto val = tok.val;
                    if (keywords.count(val))
                        tok = Token{keywords[val], val};
                    if (user_defs.count(tok.tag))
                    {
                        p -= tok.val.size();
                        tok.val = user_defs[tok.tag](content, p);
                    }
                    if (!ignore.count(tok.tag))
                        ret.push_back(tok);

                    // roll back
                    pos = p;
                    cur_state = entry;
                    cur_token = cur_tag = "";
                    pos_stac.clear();
                }
            }
            if (pos_stac.size())
                ret.push_back(pos_stac.back().second);
            return ret;
        }

    private:
        std::string content;
        int pos = 0;

        std::map<std::string, std::string> keywords;
        std::map<std::string, std::function<std::string(const std::string &, int &)>> user_defs;
        std::set<std::string> ignore;

        int entry;
        map<int, std::string> fin_stat_tab;
        vector<map<char_type, int>> tab;
    };
    
    std::string read_file(const std::string &filename)
    {
        std::ifstream ifs(filename, std::ios::in | std::ios::binary);
        if (!ifs)
            throw std::runtime_error("open file " + filename + " failed\n");
        char *file_content;
        ifs.seekg(0, std::ios::end);
        size_t file_length = ifs.tellg();
        ifs.seekg(0, std::ios::beg);

        file_content = new char[file_length];

        ifs.read(file_content, file_length);
        ifs.close();

        std::string str(file_content, file_content + file_length);
        delete[] file_content;
        return str;
    }
}
int main()
{
    HLex::Lexer L(HLex::read_file("test.txt"));
    auto vec = L.lex();
    for (auto item : vec)
    {
        std::cout << item.to_string();
    }
}
// Following code is generated by program 
namespace HLex{
Lexer::Lexer(const std::string &con):content(con),entry(24){
fin_stat_tab = {{1,"ADD"},{2,"ANNOTATION"},{3,"ASSIGN"},{4,"BEGIN"},{5,"COMMA"},{6,"DIV"},{7,"DOT"},{8,"END"},{9,"GE"},{10,"GT"},{11,"LE"},{12,"LITERAL"},{13,"LONG"},{14,"LPAR"},{15,"LT"},{16,"MUL"},{17,"NEWLINE"},{18,"NUMBER"},{19,"REAL"},{20,"RPAR"},{21,"SPACE"},{22,"SUB"},{23,"SYMBOL"}};
tab = {{{'l',13}},{},{},{},{},{},{{'/',2}},{},{},{},{{'=',9}},{},{},{},{},{{'=',11}},{},{},{{'.',26},{'0',18},{'1',18},{'2',18},{'3',18},{'4',18},{'5',18},{'6',18},{'7',18},{'8',18},{'9',18},{'l',0}},{{'0',19},{'1',19},{'2',19},{'3',19},{'4',19},{'5',19},{'6',19},{'7',19},{'8',19},{'9',19}},{},{},{},{{'0',23},{'1',23},{'2',23},{'3',23},{'4',23},{'5',23},{'6',23},{'7',23},{'8',23},{'9',23},{'A',23},{'B',23},{'C',23},{'D',23},{'E',23},{'F',23},{'G',23},{'H',23},{'I',23},{'J',23},{'K',23},{'L',23},{'M',23},{'N',23},{'O',23},{'P',23},{'Q',23},{'R',23},{'S',23},{'T',23},{'U',23},{'V',23},{'W',23},{'X',23},{'Y',23},{'Z',23},{'_',23},{'a',23},{'b',23},{'c',23},{'d',23},{'e',23},{'f',23},{'g',23},{'h',23},{'i',23},{'j',23},{'k',23},{'l',23},{'m',23},{'n',23},{'o',23},{'p',23},{'q',23},{'r',23},{'s',23},{'t',23},{'u',23},{'v',23},{'w',23},{'x',23},{'y',23},{'z',23}},{{'\t',21},{'\n',17},{'\r',25},{' ',21},{'"',12},{'(',14},{')',20},{'*',16},{'+',1},{',',5},{'-',22},{'.',7},{'/',6},{'0',18},{'1',18},{'2',18},{'3',18},{'4',18},{'5',18},{'6',18},{'7',18},{'8',18},{'9',18},{';',5},{'<',15},{'=',3},{'>',10},{'A',23},{'B',23},{'C',23},{'D',23},{'E',23},{'F',23},{'G',23},{'H',23},{'I',23},{'J',23},{'K',23},{'L',23},{'M',23},{'N',23},{'O',23},{'P',23},{'Q',23},{'R',23},{'S',23},{'T',23},{'U',23},{'V',23},{'W',23},{'X',23},{'Y',23},{'Z',23},{'_',23},{'a',23},{'b',23},{'c',23},{'d',23},{'e',23},{'f',23},{'g',23},{'h',23},{'i',23},{'j',23},{'k',23},{'l',23},{'m',23},{'n',23},{'o',23},{'p',23},{'q',23},{'r',23},{'s',23},{'t',23},{'u',23},{'v',23},{'w',23},{'x',23},{'y',23},{'z',23},{'{',4},{'}',8}},{{'\n',17}},{{'0',19},{'1',19},{'2',19},{'3',19},{'4',19},{'5',19},{'6',19},{'7',19},{'8',19},{'9',19}}};
ignore = {"ANNOTATION","SPACE"};
keywords = {{"if","IF"},{"while","WHILE"}};
user_defs = {{"ANNOTATION",[](const std::string &s,int &pos){
    while(pos<s.size() && s[pos]!='\n')
        pos++;
    return "";
}},{"LITERAL",[](const std::string &s,int &pos){
    pos++;
    std::map<char, std::string> escape = {
        {'n', "\n"}, {'t', "\t"}, {'r', "\r"}, {'\\', "\\"}};
    std::string ret = "";
    while (pos < s.size() && s[pos] != '\"')
    {
        if (s[pos] == '\\')
        {
            if (pos == s.size())
                throw std::runtime_error("invalid string");
            pos++;
            if (!escape.count(s[pos]))
                throw std::runtime_error("invalid escape string!");
            ret += escape[s[pos]];
        }
        else
            ret += s[pos];
        pos++;
    }
    pos++;
    return ret;
}}};
}}